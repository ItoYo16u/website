---
path: "query-cloudsql-with-slick"
date: "20210201"
title: "Query cloudsql with slick"
description: "ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯scalaã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªslickã‚’ä½¿ã£ã¦GCPã®cloudsqlã‚’æ“ä½œã™ã‚‹æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™."
status: "public"
tags: ["scala","slick"]
---
# slick with cloudsql
GCPã®CloudSQLã‚’slickã§æ“ä½œã™ã‚‹ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«.

ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯scalaã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªslickã‚’ä½¿ã£ã¦GCPã®cloudsqlã‚’æ“ä½œã™ã‚‹æ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™.

## preparation

1. GCPã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‹ã‚‰cloud sqlã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹(ä»Šå›ã¯mysql 8.0)
2. ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã®å·¦ãƒ‘ãƒãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’é¸æŠã—æ–°ã—ãé©å½“ãªåå‰ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½œæˆã™ã‚‹
3. cloud sql admin apiã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
4. IAMã¨ç®¡ç†ã‹ã‚‰é©å½“ãªã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ã¤ãã‚Šã€cloudSQLã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¾ãŸã¯ç·¨é›†è€…æ¨©é™ã‚’ä»˜ä¸ã—ãã®Json(xxx.json)ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦é©å½“ãªãƒ‘ã‚¹ã«é…ç½®ã™ã‚‹
5. ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã™ã‚‹. `export GOOGLE_APPLICATION_CREDENTIALS=path/to/xxx.json` 
## dependencies

slickæœ¬ä½“ã¨ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«ã€mysqlã®ã‚³ãƒã‚¯ã‚¿ã¨cloudsqlã®Socket FactoryãŒå¿…è¦.

```scala
// slick
"com.typesafe.slick" %% "slick" % "3.3.3"
// slickã§HikariCPã‚’ä½¿ã†ãŸã‚ã«å¿…è¦.
// HikariCPJdbcDataSourceã®ã‚³ãƒ³ãƒ‘ãƒ‹ã‚ªãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªã§HikariConfigã¨HikariDataSourceãŒåˆæœŸåŒ–ã•ã‚Œã‚‹
"com.typesafe.slick" %% "slickhikaricp" % "3.3.3"
// mysqlã«æ¥ç¶šã™ã‚‹ãŸã‚ã«å¿…è¦. jarã«å«ã‚ã‚‹å¿…è¦ã‚ã‚Š.
"mysql" % "mysql-connector-java" % "8.0.23"
"com.google.cloud.sql" % "mysql-socket-factory-connector-j-8" % "1.2.0"
```

## getting started

NOTE
- `Thread.currentThread().getContextClassLoader()
.loadClass("com.mysql.cj.api.io.SocketFactory")`ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€google cloudãŒæä¾›ã™ã‚‹SocketFactoryãŒã“ã£ã¡ã«castã•ã‚Œãã†ã«ãªã£ã¦ClassCastExceptionã«ãªã‚‹.
- GOOGLE_APPLICATION_CREDENTIALSãŒå¿…è¦

```scala
val hconf = new HikariConfig()
hconf.setJdbcUrl("jdbc:mysql:///dbname")
hconf.setUsername("username")
hconf.setPassword("password")
hconf.addDataSourceProperty("socketFactory","com.google.cloud.sql.mysql.SocketFactory") 
hconf.addDataSourceProperty("cloudSqlInstance","test")
hconf.addDataSourceProperty("ipTypes","PUBLIC,PRIVATE") 

val ds = new HikariDataSource(config)

// ã“ã®dsã‚’slickã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ©ãƒƒãƒ‘ãƒ¼ã«æ¸¡ã™
val conn = Database.forDataSource(ds,Some(20))
```

### application.conf(typesafe config)ã‚’ä½¿ã†

sbtãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®`resources`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä»¥ä¸‹ã«`application.conf`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®ã„ã¦ãŠãã¨è‡ªå‹•ã§èª­ã¿è¾¼ã¾ã‚Œã‚‹.

sbtãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®`src/main/resources`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«`application.conf,application.json, application.properties, reference.conf`ã¨ã„ã†åã®
ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®ã„ã¦ãŠãã¨ã“ã®é †ã«è‡ªå‹•ã§èª­ã¿è¾¼ã¾ã‚Œã‚‹.

èª­ã¿è¾¼ã¾ã‚ŒãŸè¨­å®šã¯`"namespaceA.namespaceB.key"`ã¨ã„ã†é¢¨ã«å‚ç…§ã§ãã‚‹. ã¾ãŸã€`getInt`,`getString`ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦
å‹å®‰å…¨ã«å€¤ã‚’å–å¾—ã§ãã‚‹.

```conf:title=src/main/resources/application.conf
slick-cloudsql {
  db {
    connectionPool = "HikariCP"
    keepAliveConnection = true
    url = "jdbc:mysql:///"${?CLOUDSQL_DB}
    user = ${?CLOUDSQL_USER}
    password =${?CLOUDSQL_PASSWORD}
    # datasource ã®è¨­å®š. addDataSourcePropertyã§HikariConfigã«ã‚»ãƒƒãƒˆã•ã‚Œã‚‹
    properties = {
      socketFactory = "com.google.cloud.sql.mysql.SocketFactory"
      cloudSqlInstance = ${?CLOUDSQL_INSTANCE}
      ipTypes = ${?CLOUDSQL_IP_TYPES}
    }
  }
}
```

```scala:title=Main.scala
import slick.driver.MySQLDriver.api._
class Main extends App {
  val cloudSQLConnection = Database.forConfig("slick-cloudsql.db")
  // do something
  cloudSQLConnection.close
}
```
application.confã®è¨­å®šå€¤ã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’åæ˜ ã—ãŸã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒã¤ãã‚‰ã‚Œã‚‹.


application.confã‚’ä½¿ã‚ãªã„å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹.

```scala:title=another_pattern.scala
import scala.collection.JavaConverters._
import slick.driver.MySQLDriver.api._


val configMap = Map(
  "connectionPool"->"HikariCP",
  "keepAliveConnection"->true,
  "user"->"root",
  "password"->"dbä½œæˆæ™‚ã«è¡¨ç¤ºã•ã‚ŒãŸãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰",
  "url"->"jdbc:mysql:///<ä½œæˆã—ãŸãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å>",
  "properties"-> Map(
    "socketFactory"->"com.google.cloud.sql.mysql.SocketFactory",
    "cloudSqlInstance"->"<project>:<region>:<db-instance-name>",
    "ipTypes"->"PUBLIC,PRIVATE").asJava
  ).asJava

val conf = ConfigFactory.parseMap(configMap)

val conn = Database.forConfig("",conf)


```


## Database.forConfigã®å‡¦ç†ã‚’è¿½ã£ã¦ã¿ã‚‹

`Database.forConfig`ã‚’å‘¼ã¶ã¨ã€`JdbcBackend.scala`ã®`forConfig`ãŒå‘¼ã°ã‚Œã‚‹.

`path`ã‹`config`ã§æ¸¡ã—ãŸè¨­å®šã¯`JdbcDataSource.forConfig`ã§ä½¿ã‚ã‚Œã‚‹ã‚ˆã†ã .

`path.isEmpty`ã®ã¨ãã«å¼•æ•°ã§æ¸¡ã—ãŸConfigãŒä½¿ã‚ã‚Œã‚‹.

pathã§ã¯ãªãconfigã§æŒ‡å®šã—ãŸã„æ™‚ã«`forConfig(config:Config,driver:Driver=null)` 
ã¨ã„ã†é¢¨ã«æ›¸ããŸã„ã®ã ãŒãã†ã„ã†ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ãªã„ã®ã¯ãªãœã ã‚ã†...ğŸ¤” PRå‡ºã—ã¦ã¿ã‚ˆã†ã‹...

```scala:title=JdbcBackend.scala
    def forConfig(path: String, config: Config = null, driver: Driver = null,
                  classLoader: ClassLoader = ClassLoaderUtil.defaultClassLoader): Database = {
      val initializedConfig = if(config eq null) ConfigFactory.load(classLoader) else config
      val usedConfig = if(path.isEmpty) initializedConfig else initializedConfig.getConfig(path)
      val source = JdbcDataSource.forConfig(usedConfig, driver, path, classLoader)
      val poolName = usedConfig.getStringOr("poolName", path)
      val numThreads = usedConfig.getIntOr("numThreads", 20)
      val maxConnections = source.maxConnections.getOrElse(numThreads)
      val registerMbeans = usedConfig.getBooleanOr("registerMbeans", false)
      val executor = AsyncExecutor(poolName, numThreads, numThreads, usedConfig.getIntOr("queueSize", 1000),
        maxConnections, registerMbeans = registerMbeans)
      forSource(source, executor)
    }
```

ã¡ãªã¿ã«`path`ã¯`application.conf`ã®è¨­å®š. ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ãªè¨­å®šãŒã‚ã£ãŸã‚‰`slick.mysql`ã«ãªã‚‹.


```conf
slick  {
  mysql {
    ã“ã“ã«è¨­å®šå†…å®¹ã‚’æ›¸ã
  }
}
```

`JdbcDataSource.forConfig`ã‚’ã¿ã¦ã¿ã‚‹ã¨,ã“ã“ã§`forConfig`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å‚™ãˆãŸDataSourceã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãŒç”Ÿæˆã•ã‚Œã¦ã€
ãã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªã‚’ã¤ã‹ã£ã¦DataSourceã‚’ã¤ãã£ã¦ã„ã‚‹. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯`HikariCPJdbcDataSource`.

```scala:title=JdbcDataSource.scala
  def forConfig(c: Config, driver: Driver, name: String, classLoader: ClassLoader): JdbcDataSource = {
    def loadFactory(name: String): JdbcDataSourceFactory = {
      val clazz = classLoader.loadClass(name)
      clazz.getField("MODULE$").get(clazz).asInstanceOf[JdbcDataSourceFactory]
    }
    val pf: JdbcDataSourceFactory = c.getStringOr("connectionPool", "HikariCP") match {
      case "disabled" => DataSourceJdbcDataSource
      case "HikariCP" => loadFactory("slick.jdbc.hikaricp.HikariCPJdbcDataSource$")
      case "slick.jdbc.HikariCPJdbcDataSource" =>
        logger.warn("connectionPool class 'slick.jdbc.HikariCPJdbcDataSource$' has been renamed to 'slick.jdbc.hikaricp.HikariCPJdbcDataSource$'")
        loadFactory("slick.jdbc.hikaricp.HikariCPJdbcDataSource$")
      case name => loadFactory(name)
    }
    pf.forConfig(c, driver, name, classLoader)
  }
```


# å‚è€ƒ

[Cloud SQLã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒ­ãƒ¼ã‚«ãƒ«ã‹ã‚‰æ¥ç¶šã™ã‚‹æ–¹æ³•](https://qiita.com/ryu-yama/items/f635a7608469bf019de7)